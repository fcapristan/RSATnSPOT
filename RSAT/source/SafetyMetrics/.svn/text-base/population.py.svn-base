import simpleArcReader
import numpy as np

# This functions are used to read an 'asc' type file. In this case the 'asc' file has the population density in [Persons/km^2]



def Density(X,Y,xlen,ylen,filename):
# Takes in the X, Y which are equivalent to latitude and longitude

  	#filename = 'usads05ag.asc'
	totalLength = int(xlen*ylen)
	
	xvec = np.reshape(X,totalLength) # making X a vector
	yvec = np.reshape(Y,totalLength) # making Y a vector

	popDensity = simpleArcReader.arcReader(xvec,yvec,totalLength,filename) # this result is a vector
	popDensity = np.asarray(popDensity)
	popDensity = popDensity.reshape(ylen,xlen)

	return popDensity


def DensityfromRaw(X,Y,xlen,ylen,key,xllcorner,yllcorner,cellsize,nrows,xMax):
	totalLength = int(xlen*ylen)
	
	xvec = np.reshape(X,totalLength) # making X a vector
	yvec = np.reshape(Y,totalLength) # making Y a vector

	popDensity = simpleArcReader.getVal(key,xllcorner,yllcorner,cellsize,nrows,xMax,xvec,yvec,totalLength)
	popDensity = np.asarray(popDensity)
	popDensity = popDensity.reshape(ylen,xlen)
	return popDensity

def DensityRaw(filename):
# simply making a call to simpleArcReader, check simpleArcReader for information
# This function is here just to keep all the population calls together, this function could be avoided all together
	key,xllcorner,yllcorner,cellsize,nrows,ncols,xMax,yMax = simpleArcReader.getRawVals(filename)
	return (key,xllcorner,yllcorner,cellsize,nrows,xMax)




def gridSize(filename):
# this function return the cellsize for an asc file
	try:
		inputFile = open(filename,'r')
	except:
		print 'Cannot open file==> ERROR in population.gridSize'

	for line in inputFile:
		key = line.split()
		if key[0] == 'cellsize':
			cellsize = float(key[1])
			break
	return cellsize
def cellArea(filename):
	import math
# Calculates the area of each grid in meter square by assuming a perfect spherical earth
# this section could improve later on to include Earth's oblateness
	cellsize = gridSize(filename)
	cellsize = cellsize*(math.pi)/180.0 # converting cellsize to radians
	earthRadius = 6378.145*1000.0 # [m]
	deltaL = earthRadius*cellsize
	areaCell = deltaL*deltaL
	return areaCell # in meters^2

def deltaArea(delta):
	import math
# calculates the area of a selected delta[deg] by assuming a spherical Earth
	earthRadius = 6378.145*1000.0 # [m]
	delta = delta*(math.pi)/180.0
	deltaL = delta*earthRadius
	area = deltaL*deltaL
	return area

def interestArea(meanList,covarList):
# Calculates the area of interest by taking in all the results from all groups
# the result is a big rectangle that contains the areas of interest
	
	nGroups = len(meanList)

	XU = -999.0
	XL =  999.0
	YU = -999.0
	YL = 999.0
	nSigma = 5.0
	for index in range(0,nGroups):
		mu = meanList[index]
		covar = covarList[index]
		if mu!='NAN':
			sigma1 = np.sqrt(covar[0,0])
			sigma2 = np.sqrt(covar[1,1])
			xmin = mu[0]-nSigma*sigma1
			xmax = mu[0]+nSigma*sigma1
			ymin = mu[1]-nSigma*sigma2
			ymax = mu[1]+nSigma*sigma2
			if XL >xmin:
				XL = xmin
			if XU < xmax:
				XU = xmax
			if YL > ymin:
				YL = ymin
			if YU < ymax :
				YU = ymax

	return (XL,XU,YL,YU)

def interestAreaGauss(mu,covar):
	XU = -999.0
	XL =  999.0
	YU = -999.0
	YL = 999.0
	nSigma = 5.0
	sigma1 = np.sqrt(covar[0,0])
	sigma2 = np.sqrt(covar[1,1])
	xmin = mu[0]-nSigma*sigma1
	xmax = mu[0]+nSigma*sigma1
	ymin = mu[1]-nSigma*sigma2
	ymax = mu[1]+nSigma*sigma2
	if XL >xmin:
		XL = xmin
	if XU < xmax:
		XU = xmax
	if YL > ymin:
		YL = ymin
	if YU < ymax :
		YU = ymax

	return (XL,XU,YL,YU)
	

def interestAreaKernel(y):
# y is just a nx2 numpy array with lon lat
	noffset = .25 #1.5 bu default...need to work on this parameter
	xb = y[:,0]
	yb = y[:,1]
	XL = min(xb)
	XU = max(xb)
	YL = min(yb)
	YU = max(yb)
	
	dx = XU-XL
	dy = YU-YL
	XL = XL-noffset*dx
	XU = XU+noffset*dx
	YL = YL-noffset*dy
	YU = YU+noffset*dy
	return (XL,XU,YL,YU)
		
	
	
