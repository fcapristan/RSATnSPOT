# routines to calculate a gaussian distribution (from debris) in a circular planet. 


import numpy as np
import sys
sys.path.append("../STATS/kernelQuadCpp")
#sys.path.append("../STATS")
import meancov
import statsPython
import lonlatChecks
import serialKernel as SK
import matplotlib.pyplot as plt


def getCorrelation2InRotatedFrame(beta,vals):
    # lon0, lat0 : main vehicle lat and lon used as initial conditions for debris propagation
    # beta : main vehicle heading angle (counterclockwise starting East) [deg]
    
    lonlat = vals[0]
    nSamples = vals[1]
    lon0 = vals[2]
    lat0 = vals[3]
    R1 = Rotz(lon0*np.pi/180.) # generating rotation matrices
    R2 = Roty(-lat0*np.pi/180.)
    R3 = Rotx(beta*np.pi/180.)
    
    Uint = np.dot(R2,R1)
    U  = np.dot(R3,Uint)
    UT = U.T
    xyz,x,y,z = getxyz(lonlat)
    pqr = np.dot(U,xyz) # rotating point to new frame...(P frame)
    p = pqr[0,:] 
    q = pqr[1,:]
    r = pqr[2,:]
    lonlatPframe = getlonlat(p,q,r)
    lonlatPframe = lonlatChecks.fixlon4pdf(lonlatPframe,nSamples)
    mean,covar = meancov.meancovmatrix(lonlatPframe,nSamples)
    #D,Ulocal = np.linalg.eig(covar)
    #lonlatAframe = np.dot(lonlatPframe,Ulocal) 
    #lonlatAframe = lonlatChecks.fixlon4pdf(lonlatAframe,nSamples)
    
    #mean,covar = meancov.meancovmatrix(lonlatAframe,nSamples)
    sigma1 = (covar[0,0])**.5
    sigma2 = (covar[1,1])**.5
    correlation = covar[0,1]/(sigma1*sigma2)
    #print sigma1,sigma2,correlation

    return abs(correlation)*sigma2 # objective function for optimization part (minimizing rho) 

def optimizeHeadingAngle(lonlat,nSamples,lon0,lat0,beta):
    from scipy.optimize import fmin
    vals = [lonlat,nSamples,lon0,lat0]
    res = fmin(getCorrelation2InRotatedFrame,beta,[vals],disp=0)
    return res




def getPDF(lonlat,nSamples,delta,nsigma,pdfoption):
    # lon0, lat0 : main vehicle lat and lon used as initial conditions for debris propagation
    # beta : main vehicle heading angle (counterclockwise starting East) [deg]
    
    
    xyz,x,y,z = getxyz(lonlat)
    xmean = np.mean(x)
    ymean = np.mean(y)
    zmean = np.mean(z)
    mag = (xmean**2+ymean**2+zmean**2)**.5
    lonlat0 = getlonlat(xmean/mag,ymean/mag,zmean/mag)
    lon0 = lonlat0[0,0]
    lat0 = lonlat0[0,1]
    beta = 0 # initial guess
    beta = optimizeHeadingAngle(lonlat,nSamples,lon0,lat0,beta)

    R1 = Rotz(lon0*np.pi/180.) # generating rotation matrices
    R2 = Roty(-lat0*np.pi/180.)
    R3 = Rotx(beta*np.pi/180.)
    transformDetails = [R1,R2,R3,lon0,lat0,beta]
    
    Uint = np.dot(R2,R1)
    U  = np.dot(R3,Uint)
    lonlatPframe = originalFrame2Pframe(lonlat,U)
    # error check for this case not yet implemented
    
    #mean,covar = meancov.meancovmatrix(lonlatPframe,nSamples)
    #D,Ulocal = np.linalg.eig(covar)

    #lonlatAframe = np.dot(lonlatPframe,Ulocal) 
    
    
    
    #    ZZ = meancov.normalbivariate(mean,covar,XX,YY,xlen,ylen) #fortran version
    if pdfoption.lower()=='kde' or pdfoption.lower()=='kernel':
        xMeshP,yMeshP,xlen,ylen= statsPython.areaOfInterestKDE(lonlatPframe,delta) # A frame could also be used
    elif pdfoption=='normal' or pdfoption=='gaussian' or pdfoption=='gauss':
        mean,covar = meancov.meancovmatrix(lonlatPframe,nSamples)
        xMeshP,yMeshP,xlen,ylen = statsPython.areaOfInterest(mean,covar,delta,nsigma)
   
        
    lonlatPframeMesh = np.zeros((np.size(xMeshP),2))
    lonlatPframeMesh[:,0] = np.reshape(xMeshP,np.size(xMeshP))
    lonlatPframeMesh[:,1] = np.reshape(yMeshP,np.size(yMeshP))
    lonlatOrFrameMesh = Pframe2originalFrame(lonlatPframeMesh,U)
    lonMesh,latMesh = getLonLatMesh(lonlatOrFrameMesh[:,0],lonlatOrFrameMesh[:,1],delta)

    lonVec = np.reshape(lonMesh,np.size(lonMesh))
    latVec = np.reshape(latMesh,np.size(latMesh))
    lonlatVec = np.zeros((len(lonVec),2))
    lonlatVec[:,0] = lonVec
    lonlatVec[:,1] = latVec
    lonlatVecP = originalFrame2Pframe(lonlatVec,U)
    ylen,xlen = np.shape(lonMesh)
    lonMeshP = np.reshape(lonlatVecP[:,0],[ylen,xlen])
    latMeshP = np.reshape(lonlatVecP[:,1],[ylen,xlen])


    pqrVec ,pVec,qVec,rVec= getxyz(lonlatVecP) # mesh locations in P frame

          
    if pdfoption.lower()=='kde' or pdfoption.lower()=='kernel':
        #ZZpdf = meancov.kde(lonlatPframe,lonMeshP,latMeshP,[nSamples, xlen,ylen])
        print 'Starting quad KDE'
        ZZpdf = SK.serialK(nSamples,lonlatPframe,ylen,xlen,lonMeshP,latMeshP,.1,1)
        print 'Done with quad KDE'
    elif pdfoption=='normal' or pdfoption=='gaussian' or pdfoption=='gauss':
        ZZpdf = meancov.normalbivariate(mean,covar,lonMeshP,latMeshP,xlen,ylen) #fortran version

 
    pdfN = transformPDF(U,pqrVec,np.pi/180*lonlatVec[:,0],np.pi/180*lonlatVec[:,1],np.reshape(ZZpdf,xlen*ylen))
    ZZpdfN = np.reshape(pdfN,[ylen,xlen])
    #plt.figure()
    #plt.contourf(lonMesh,latMesh,np.reshape(pdfN,[ylen,xlen]))
    #plt.show()
    return (lonMesh,latMesh,ZZpdfN,lonMeshP,latMeshP,xlen,ylen,transformDetails) #





def getPDF2(lonlat,nSamples,delta,nsigma,pdfoption):
    # lon0, lat0 : main vehicle lat and lon used as initial conditions for debris propagation
    # beta : main vehicle heading angle (counterclockwise starting East) [deg]
    #import time
    
    xyz,x,y,z = getxyz(lonlat)
    xmean = np.mean(x)
    ymean = np.mean(y)
    zmean = np.mean(z)
    mag = (xmean**2+ymean**2+zmean**2)
    lonlat0 = getlonlat(xmean/mag,ymean/mag,zmean/mag)
    lon0 = lonlat0[0,0]
    lat0 = lonlat0[0,1]
    beta = 0 # initial guess
    beta = optimizeHeadingAngle(lonlat,nSamples,lon0,lat0,beta)
    
    R1 = Rotz(lon0*np.pi/180.) # generating rotation matrices
    R2 = Roty(-lat0*np.pi/180.)
    R3 = Rotx(beta*np.pi/180.)
    transformDetails = [R1,R2,R3,lon0,lat0,beta]
    
    Uint = np.dot(R2,R1)
    U  = np.dot(R3,Uint)
    lonlatPframe = originalFrame2Pframe(lonlat,U)

    # error check for this case not yet implemented
    
    #mean,covar = meancov.meancovmatrix(lonlatPframe,nSamples)
    #D,Ulocal = np.linalg.eig(covar)
    
    #lonlatAframe = np.dot(lonlatPframe,Ulocal) 
    
    
    #    ZZ = meancov.normalbivariate(mean,covar,XX,YY,xlen,ylen) #fortran version
    if pdfoption.lower()=='kde' or pdfoption.lower()=='kernel':
        xMeshP,yMeshP,xlen,ylen= statsPython.areaOfInterestKDE(lonlatPframe,delta) # A frame could also be used
    
    elif pdfoption=='normal' or pdfoption=='gaussian' or pdfoption=='gauss':
        mean,covar = meancov.meancovmatrix(lonlatPframe,nSamples)
        xMeshP,yMeshP,xlen,ylen = statsPython.areaOfInterest(mean,covar,delta,nsigma)
    
    lonlatPframeMesh = np.zeros((np.size(xMeshP),2))
    lonlatPframeMesh[:,0] = np.reshape(xMeshP,np.size(xMeshP))
    lonlatPframeMesh[:,1] = np.reshape(yMeshP,np.size(yMeshP))
    row,col = np.shape(xMeshP)
    #print xMeshP
    if pdfoption.lower()=='kde' or pdfoption.lower()=='kernel':
        
  
        ZZpdfPframe = SK.serialK(int(nSamples),lonlatPframe,row,col,xMeshP,yMeshP,.0,0)
 
    elif pdfoption=='normal' or pdfoption=='gaussian' or pdfoption=='gauss':
        ZZpdfPframe = meancov.normalbivariate(mean,covar,xMeshP,yMeshP,col,row) #fortran version    
    #ZZpdf on P frame

    
    lonlatOrFrameMesh = Pframe2originalFrame(lonlatPframeMesh,U)
    lonOrMesh = np.reshape(lonlatOrFrameMesh[:,0],[ylen,xlen])
    latOrMesh = np.reshape(lonlatOrFrameMesh[:,1],[ylen,xlen])

#ZZpdfPframe0 = np.reshape(ZZpdfPframe0,[ylen,xlen])
    '''
    print 'maxABS',np.max(np.abs(ZZpdfPframe-ZZpdfPframe0))
    plt.figure()
    plt.contourf(xMeshP,yMeshP,ZZpdfPframe)
    plt.figure()
    plt.contourf(xMeshP,yMeshP,ZZpdfPframe0)
    plt.figure()
    plt.contourf(xMeshP,yMeshP,ZZpdfPframe0-ZZpdfPframe)


    plt.figure()
    plt.plot(lonlatPframe[:,0],lonlatPframe[:,1],'x')
    plt.figure()
    plt.contourf(lonOrMesh,latOrMesh,ZZpdfPframe)
    plt.plot(lonlat[:,0],lonlat[:,1],'x')
    plt.show()
    '''
    return (xMeshP,yMeshP,ZZpdfPframe,lonOrMesh,latOrMesh,xlen,ylen,transformDetails) #


def pdfSetup(lonlat,nSamples,delta,nsigma,pdfoption):
         

    # lon0, lat0 : main vehicle lat and lon used as initial conditions for debris propagation
    # beta : main vehicle heading angle (counterclockwise starting East) [deg]
    #import time

    xyz,x,y,z = getxyz(lonlat)
    xmean = np.mean(x)
    ymean = np.mean(y)
    zmean = np.mean(z)
    mag = (xmean**2+ymean**2+zmean**2)
    lonlat0 = getlonlat(xmean/mag,ymean/mag,zmean/mag)
    lon0 = lonlat0[0,0]
    lat0 = lonlat0[0,1]
    beta = 0 # initial guess
    beta = optimizeHeadingAngle(lonlat,nSamples,lon0,lat0,beta)

    R1 = Rotz(lon0*np.pi/180.) # generating rotation matrices
    R2 = Roty(-lat0*np.pi/180.)
    R3 = Rotx(beta*np.pi/180.)
    transformDetails = [R1,R2,R3,lon0,lat0,beta]

    Uint = np.dot(R2,R1)
    U  = np.dot(R3,Uint)
    lonlatPframe = originalFrame2Pframe(lonlat,U)

    # error check for this case not yet implemented

    #mean,covar = meancov.meancovmatrix(lonlatPframe,nSamples)
    #D,Ulocal = np.linalg.eig(covar)

    #lonlatAframe = np.dot(lonlatPframe,Ulocal) 

    #    ZZ = meancov.normalbivariate(mean,covar,XX,YY,xlen,ylen) #fortran version
    if pdfoption.lower()=='kde' or pdfoption.lower()=='kernel':
        xMeshP,yMeshP,xlen,ylen= statsPython.areaOfInterestKDE(lonlatPframe,delta) # A frame could also be used

    elif pdfoption=='normal' or pdfoption=='gaussian' or pdfoption=='gauss':
        mean,covar = meancov.meancovmatrix(lonlatPframe,nSamples)
        xMeshP,yMeshP,xlen,ylen = statsPython.areaOfInterest(mean,covar,delta,nsigma)
            
            
            
    lonlatPframeMesh = np.zeros((np.size(xMeshP),2))
    lonlatPframeMesh[:,0] = np.reshape(xMeshP,np.size(xMeshP))
    lonlatPframeMesh[:,1] = np.reshape(yMeshP,np.size(yMeshP))

            
    lonlatOrFrameMesh = Pframe2originalFrame(lonlatPframeMesh,U)
    lonOrMesh = np.reshape(lonlatOrFrameMesh[:,0],np.shape(xMeshP))
    latOrMesh = np.reshape(lonlatOrFrameMesh[:,1],np.shape(xMeshP))


    return (lonlatPframe,lonOrMesh,latOrMesh,U,xMeshP,yMeshP,transformDetails)



def getPDFfromSetup(nSamples,pdfoption,lonlatPframe,lonOrMesh,latOrMesh,U,xMeshP,yMeshP):

    row,col = np.shape(xMeshP)
    #print xMeshP
    if pdfoption.lower()=='kde' or pdfoption.lower()=='kernel':
        
        
        ZZpdfPframe = SK.serialK(int(nSamples),lonlatPframe,row,col,xMeshP,yMeshP,.0,0)
    
    elif pdfoption=='normal' or pdfoption=='gaussian' or pdfoption=='gauss':
        ZZpdfPframe = meancov.normalbivariate(mean,covar,xMeshP,yMeshP,col,row) #fortran version    
    #ZZpdf on P frame
    


    #xlen,ylen = np.shape(xMeshP)
    return (xMeshP,yMeshP,ZZpdfPframe,lonOrMesh,latOrMesh)

def calculateEcRotatedFrame(lonlat,nSamples,delta,nsigma,key,xllcorner,yllcorner,cellsize,xMax,yMax,boundsOption,ncols,nrows,nPieces,arefMean,pdfoption):
    # calculates Ec by calculating pdf in P frame, then get corresponding population density for P frame.
    sys.path.append("../SafetyMetrics")
    import safetyMetrics as SMF
    
    # this version uses the rotated pdf (actual lon lat coordinates)
    areapop = delta*delta
    tempval = .3048 #1ft to meters
    lonPMesh,latPMesh,ZZpdfPframe,lonOrMesh,latOrMesh,xlen,ylen,transformDetails  = getPDF2(lonlat,nSamples,delta,nsigma,pdfoption)
    popMatrix = SMF.agsgetvals(key,xllcorner,yllcorner,cellsize,lonOrMesh,latOrMesh,xMax,yMax,boundsOption,[ncols,nrows,ylen,xlen])
    Ec = nPieces*(SMF.calculateec(ZZpdfPframe,areapop,arefMean,tempval,popMatrix,[ylen,xlen]))
    return (Ec,lonPMesh,latPMesh,ZZpdfPframe)



def calculateEcBlast(lon,lat,keyPop,keyArea,xllcorner,yllcorner,cellsize,xMax,yMax,boundsOption,ncols,nrows,areaBlast):
    import sys
    sys.path.append("../SafetyMetrics")
    import safetyMetrics as SMF
    
    popdensity,xmatlocations,ymatlocations = SMF.agsgetdensity(keyPop,keyArea,xllcorner,yllcorner,cellsize,[lon],[lat],xMax,yMax,boundsOption,[ncols,nrows,1,1])
    #print 'Popden',popdensity
    Ec = popdensity*areaBlast*(.001)**2
    return (Ec[0,0],xmatlocations[0,0],ymatlocations[0,0])

def calculateEcMatrix(lonlat,nSamples,delta,nsigma,keyPop,keyArea,xllcorner,yllcorner,cellsize,xMax,yMax,boundsOption,ncols,nrows,nPieces,arefMean,pdfoption):
    import sys
    sys.path.append("../SafetyMetrics")
    import safetyMetrics as SMF
    
    # this version uses the rotated pdf (actual lon lat coordinates). Gets pdf in regular frame, and integrates it. Inneficient for big ranges of lat lon (memory intensive)
    areapop = delta*delta
    tempval = .3048 #1ft to meters
    lonPMesh,latPMesh,ZZpdfPframe,lonOrMesh,latOrMesh,xlen,ylen,transformDetails  = getPDF2(lonlat,nSamples,delta,nsigma,pdfoption)
    #popMatrix = SMF.agsgetvals(key,xllcorner,yllcorner,cellsize,lonMesh,latMesh,xMax,yMax,boundsOption,[ncols,nrows,ylen,xlen])
    #popMatrix = SMF.agsgetvals(key,xllcorner,yllcorner,cellsize,lonOrMesh,latOrMesh,xMax,yMax,boundsOption,[ncols,nrows,ylen,xlen])

    popMatrix,xmatlocations,ymatlocations = SMF.agsgetdensity(keyPop,keyArea,xllcorner,yllcorner,cellsize,lonOrMesh,latOrMesh,xMax,yMax,boundsOption,[ncols,nrows,xlen,ylen])
    Ec,Ecmatrix = SMF.calculateecmatrix(ZZpdfPframe,areapop,arefMean,tempval,popMatrix,[ylen,xlen])
    Ec = nPieces*Ec
    Ecmatrix = nPieces*Ecmatrix
    #Ec = nPieces*(SMF.calculateec(ZZpdf,areapop,arefMean,tempval,popMatrix,[ylen,xlen]))
    return (Ec,Ecmatrix,xmatlocations,ymatlocations)


def calculateEc(lonlat,nSamples,delta,nsigma,key,xllcorner,yllcorner,cellsize,xMax,yMax,boundsOption,ncols,nrows,nPieces,arefMean,pdfoption):
    import sys
    sys.path.append("../SafetyMetrics")
    import safetyMetrics as SMF

    # this version uses the rotated pdf (actual lon lat coordinates). Gets pdf in regular frame, and integrates it. Inneficient for big ranges of lat lon (memory intensive)
    areapop = delta*delta
    tempval = .3048 #1ft to meters
    lonMesh,latMesh,ZZpdf,XX,YY,xlen,ylen,transformDetails  = getPDF(lonlat,nSamples,delta,nsigma,pdfoption)
    popMatrix = SMF.agsgetvals(key,xllcorner,yllcorner,cellsize,lonMesh,latMesh,xMax,yMax,boundsOption,[ncols,nrows,ylen,xlen])
    Ec = nPieces*(SMF.calculateec(ZZpdf,areapop,arefMean,tempval,popMatrix,[ylen,xlen]))
    return (Ec,lonMesh,latMesh,ZZpdf)


def calculateEcMatrixSheltering(lonlat,nSamples,delta,nsigma,keyPop,keyArea,xllcorner,yllcorner,cellsize,xMax,yMax,boundsOption,ncols,nrows,nPieces,casualtyArea,pdfoption,roofFraction):
    # calculates Ec by calculating pdf in P frame, then get corresponding population density for P frame.
    #print 'Npieces IN',nPieces
    if nPieces>0:
        sys.path.append("../SafetyMetrics")
        import safetyMetrics as SMF 
        # this version uses the rotated pdf (actual lon lat coordinates)
        popOrigArea = cellsize**2
        areapop = delta*delta
        tempval = .3048 #1ft to meters
        
        
        lonlatPframe,lonOrMesh,latOrMesh,U,xMeshP,yMeshP,transformDetails = pdfSetup(lonlat,nSamples,delta,nsigma,pdfoption)
        ylen,xlen = np.shape(xMeshP)
        popMatrix,xmatlocations,ymatlocations = SMF.agsgetdensity(keyPop,keyArea,xllcorner,yllcorner,cellsize,lonOrMesh,latOrMesh,xMax,yMax,boundsOption,[ncols,nrows,xlen,ylen])
        if np.sum(popMatrix)>0.0:
            lonPMesh,latPMesh,ZZpdfPframe,lonOrMesh,latOrMesh = getPDFfromSetup(nSamples,pdfoption,lonlatPframe,lonOrMesh,latOrMesh,U,xMeshP,yMeshP)
                
            Ec,Ecmatrix = SMF.calculateecmatrixshelteringpopdensity(ZZpdfPframe,areapop,casualtyArea,roofFraction,tempval,popMatrix,ylen,xlen,len(casualtyArea))
            #ec,ecmatrix = calculateecmatrixshelteringpopdensity(f,area,casualtyarea,rooffraction,rp,popdensity,frows=shape(f,0),fcols=shape(f,1),nroofs=len(casualtyarea))
            Ec = nPieces*Ec
            Ecmatrix = nPieces*Ecmatrix
            #Ec = nPieces*(SMF.calculateecshelteringpopdensity(ZZpdfPframe,areapop,casualtyArea,roofFraction,tempval,popMatrix,popOrigArea,[ylen,xlen,len(casualtyArea)]))
            #Ec2 = nPieces*(SMF.calculateec(ZZpdfPframe,areapop,casualtyArea[-1],tempval,popMatrix,[ylen,xlen]))
            #return (Ec,lonPMesh,latPMesh,ZZpdfPframe)
        else:
            print 'No pdf calc',np.sum(popMatrix)
            Ec = 0.0
            #Ec2 = 0.0
            xmatlocations = [1]
            ymatlocations = [1]
            Ecmatrix = np.zeros((1,1))
        '''
        lonPMesh,latPMesh,ZZpdfPframe,lonOrMesh,latOrMesh,xlen,ylen,transformDetails  = getPDF2(lonlat,nSamples,delta,nsigma,pdfoption)
        #popMatrix = SMF.agsgetvals(key,xllcorner,yllcorner,cellsize,lonOrMesh,latOrMesh,xMax,yMax,boundsOption,[ncols,nrows,ylen,xlen])
        popMatrix,xmatlocations,ymatlocations = SMF.agsgetdensity(keyPop,keyArea,xllcorner,yllcorner,cellsize,lonOrMesh,latOrMesh,xMax,yMax,boundsOption,[ncols,nrows,xlen,ylen])
        '''

        
    else:
        Ec = 0.0
        #Ec2 = 0.0
        xmatlocations = [1]
        ymatlocations = [1]
        Ecmatrix = np.zeros((1,1))
    return Ec,Ecmatrix,xmatlocations,ymatlocations#,Ec2


def calculateEcSheltering(lonlat,nSamples,delta,nsigma,populationVals,boundsOption,nPieces,pdfoption,casualtyArea,roofFraction):
    # calculates Ec by calculating pdf in P frame, then get corresponding population density for P frame.
    key,xllcorner,yllcorner,cellsize,nrows,ncols,xMax,yMax = populationVals
    if nPieces>0:
        sys.path.append("../SafetyMetrics")
        import safetyMetrics as SMF 
        # this version uses the rotated pdf (actual lon lat coordinates)
        popOrigArea = cellsize**2
        areapop = delta*delta
        tempval = .3048 #1ft to meters
        lonPMesh,latPMesh,ZZpdfPframe,lonOrMesh,latOrMesh,xlen,ylen,transformDetails  = getPDF2(lonlat,nSamples,delta,nsigma,pdfoption)
        #lonPMesh,latPMesh,ZZpdfPframe,lonOrMesh,latOrMesh,ylen,xlen,transformDetails  = getPDF2(lonlat,nSamples,delta,nsigma,pdfoption)

        popMatrix = SMF.agsgetvals(key,xllcorner,yllcorner,cellsize,lonOrMesh,latOrMesh,xMax,yMax,boundsOption,[ncols,nrows,ylen,xlen])
        
        
        Ec = nPieces*(SMF.calculateecshelteringpopdensity(ZZpdfPframe,areapop,casualtyArea,roofFraction,tempval,popMatrix,popOrigArea,[ylen,xlen,len(casualtyArea)]))
        #Ec = nPieces*(SMF.calculateec(ZZpdfPframe,areapop,arefMean,tempval,popMatrix,[ylen,xlen]))
        #return (Ec,lonPMesh,latPMesh,ZZpdfPframe)
        return Ec
    else:
        Ec = 0.0
        
        return Ec

def calculateEcShelteringV2(lonlat,nSamples,delta,nsigma,populationVals,boundsOption,nPieces,pdfoption,casualtyArea,roofFraction):
    # calculates Ec by calculating pdf in P frame, then get corresponding population density for P frame.
    keyPop,keyArea,xllcorner,yllcorner,cellsize,nrows,ncols,xMax,yMax = populationVals
    if nPieces>0:
        sys.path.append("../SafetyMetrics")
        import safetyMetrics as SMF 
        # this version uses the rotated pdf (actual lon lat coordinates)
        popOrigArea = cellsize**2
        areapop = delta*delta
        tempval = .3048 #1ft to meters
        lonPMesh,latPMesh,ZZpdfPframe,lonOrMesh,latOrMesh,xlen,ylen,transformDetails  = getPDF2(lonlat,nSamples,delta,nsigma,pdfoption)
        #lonPMesh,latPMesh,ZZpdfPframe,lonOrMesh,latOrMesh,ylen,xlen,transformDetails  = getPDF2(lonlat,nSamples,delta,nsigma,pdfoption)

        #popMatrix = SMF.agsgetvals(key,xllcorner,yllcorner,cellsize,lonOrMesh,latOrMesh,xMax,yMax,boundsOption,[ncols,nrows,ylen,xlen])
        #popdensity,xmatlocations,ymatlocations = SMF.agsgetdensity(keyPop,keyArea,xllcorner,yllcorner,cellsize,[lon],[lat],xMax,yMax,boundsOption,[ncols,nrows,xlen,ylen])
        popdensity,xmatlocations,ymatlocations = SMF.agsgetdensity(keyPop,keyArea,xllcorner,yllcorner,cellsize,lonOrMesh,latOrMesh,xMax,yMax,boundsOption,[ncols,nrows,xlen,ylen])

        #ec,ecmatrix = calculateecmatrix(f,area,aproj,rp,popdensity,[frows,fcols])
        #print np.shape(ZZpdfPframe)
        #print xlen,ylen
        #print areapop,casualtyArea,roofFraction
        Ec = nPieces*(SMF.calculateecshelteringpopdensity(ZZpdfPframe,areapop,casualtyArea,roofFraction,tempval,popdensity))
        #arefMean = casualtyArea[-1]
        #Ec = nPieces*(SMF.calculateec(ZZpdfPframe,areapop,arefMean,tempval,popdensity,[ylen,xlen]))

        #Ec = nPieces*(SMF.calculateec(ZZpdfPframe,areapop,arefMean,tempval,popMatrix,[ylen,xlen]))
        #return (Ec,lonPMesh,latPMesh,ZZpdfPframe)
        return Ec
    else:
        Ec = 0.0
        return Ec

def PDFMesh2RectangularPDF(lonMesh,latMesh,ZZ,delta):
    # delta is grid spacing !!! NOTE THAT RESULTING MESH IS NOT A PDF!!! DOES NOT INTEGRATE TO ONE!!! JUST FOR VISUALIZATION

    lonMeshVec = np.reshape(lonMesh,lonMesh.size)
    latMeshVec = np.reshape(latMesh,latMesh.size)
    Zvec = np.reshape(ZZ,ZZ.size)
    lonrect = np.arange(lonMeshVec.min()-2.*delta,lonMeshVec.max()+2.*delta,delta)
    latrect = np.arange(latMeshVec.max()+2.*delta,latMeshVec.min()-2.*delta,-delta)
    lonCorner = lonrect[0]-.5*delta
    latCorner = latrect[-1]-.5*delta
    lonMeshrect,latMeshrect = np.meshgrid(lonrect,latrect)
    Zrect = lonlatChecks.rectangulargrid(lonMeshVec,latMeshVec,Zvec,delta,lonCorner,latCorner,lonrect.size,latrect.size,lonMeshVec.size)
    #print 'new int',np.sum(Zrect*(delta**2))
    #plt.figure()
    #plt.contourf(lonMeshrect,latMeshrect,Zrect)
    #plt.show()

    return (lonMeshrect,latMeshrect,Zrect,lonrect.size,latrect.size)





def getxyz(lonlat):
    deg2rad = np.pi/180.
    lon = deg2rad*lonlat[:,0]
    lat = deg2rad*lonlat[:,1]
    #x = np.zeros(nSamples)
    #y = np.zeros(nSamples)
    #z = np.zeros(nSamples)


    x = np.cos(lat)*np.cos(lon)
    y = np.cos(lat)*np.sin(lon)
    z = np.sin(lat)
    xyz = np.zeros((3,len(x)))
    xyz[0,:] = x
    xyz[1,:] = y
    xyz[2,:] = z

    return(xyz,x,y,z)
def singlexyz(lonlat):

    deg2rad = np.pi/180.
    lon = deg2rad*lonlat[0]
    lat = deg2rad*lonlat[1]

    
    x = np.cos(lat)*np.cos(lon)
    y = np.cos(lat)*np.sin(lon)
    z = np.sin(lat)

    xyz = np.array([x,y,z])
    return xyz




def getlonlat(x,y,z):
    if isinstance(x,float):
        lonlat = np.zeros((1,2))
    else:
        lonlat = np.zeros((len(x),2))
    lonlat[:,0] = 180./np.pi*np.arctan2(y,x)
    lonlat[:,1] = 180./np.pi*np.arctan2(z,np.sqrt(x**2+y**2))

    return lonlat
    
def Rotz(theta):
    R = np.array([[np.cos(theta),np.sin(theta),0],
                   [-np.sin(theta),np.cos(theta),0],
                   [0,0,1]])
    
    return R



def Roty(theta):
    R = np.array([[np.cos(theta),0,-np.sin(theta)],
                   [0,1,0],
                   [np.sin(theta),0,np.cos(theta)]])
    
    return R


def Rotx(theta):
    R = np.array([[1.,0,0],
                  [0.,np.cos(theta),np.sin(theta)],
                  [0.,-np.sin(theta),np.cos(theta)]])
    
    return R


def transformPDF(ROT,pqrVec,uVec,vVec,pdfVec):
# form needed is fuv(u,v) = fxy(h1(x,y),h2(x,y))*abs(det(Jacobian(u,v))), det(Jacobian(u,v)) = (det(Jacobian(x,y)))^-1
# routine to transform pdf in actual lat lon
    
    pdfVecN = np.zeros((len(pdfVec),1))
    for index in range(0,len(pdfVec)):
        pqr = pqrVec[:,index]
        detJXY = getdetJacobianXY(ROT,pqr,uVec[index],vVec[index])
        pdfVecN[index,0] = pdfVec[index]*abs(detJXY)
    return (pdfVecN)




# this section just for derivative calculation (Jacobian) to translate pdf to new frame


def getdetJacobianXY(ROT,pqr,u,v):
# form needed is fuv(u,v) = fxy(h1(x,y),h2(x,y))*abs(det(Jacobian(u,v))), det(Jacobian(u,v)) = (det(Jacobian(x,y)))^-1
# Derivative deriavation in Francisco Capristan's research notes
    dxdpqr,dydqpr = getdxdydqpr(pqr)
    dpqrdu,dpqrdv = getdpqrduv(ROT,u,v)
    dxdu = dxdpqr[1]*dpqrdu[1,0] + dxdpqr[0]*dpqrdu[0,0]
    dxdv = dxdpqr[1]*dpqrdv[1,0] + dxdpqr[0]*dpqrdv[0,0]
    dydu = dydqpr[0]*dpqrdu[0,0] + dydqpr[1]*dpqrdu[1,0] + dydqpr[2]*dpqrdu[2,0]
    dydv = dydqpr[0]*dpqrdv[0,0] + dydqpr[1]*dpqrdv[1,0] + dydqpr[2]*dpqrdv[2,0]
    detJXY = dxdu*dydv-dxdv*dydu
    #print 'tm',dxdpqr[1]*dpqrdv[1,0],dxdpqr[0]*dpqrdv[0,0]
    #print dxdu,dxdv,dydu,dydv
    return (detJXY)

def getdxdydqpr(pqr):
    pqr1 = pqr[0]
    pqr2 = pqr[1]
    pqr3 = pqr[2]
    pqrSQ = pqr1**2+pqr2**2
    dxdpqr1 = -pqr2/(pqrSQ)
    dxdpqr2 = pqr1/pqrSQ
    dydqpr1 = -pqr1*pqr3/(np.sqrt(pqrSQ)*(pqr1**2+pqr2**2+pqr3**2))
    dydqpr2 = -pqr2*pqr3/(np.sqrt(pqrSQ)*(pqr1**2+pqr2**2+pqr3**2))
    dydqpr3 = np.sqrt(pqrSQ)/(pqr3**2 + pqrSQ)

    dxdpqr = [dxdpqr1,dxdpqr2]
    dydqpr = [dydqpr1,dydqpr2,dydqpr3]
    return (dxdpqr,dydqpr)

def getdpqrduv(ROT,u,v):
    duvec = np.array([[-np.cos(v)*np.sin(u)],[np.cos(v)*np.cos(u)],[0.0]])
    dvvec = np.array([[-np.sin(v)*np.cos(u)],[-np.sin(v)*np.sin(u)],[np.cos(v)]])

    dpqrdu = np.dot(ROT,duvec)
    dpqrdv = np.dot(ROT,dvvec)
    #print dpqrdv
    return (dpqrdu,dpqrdv)

def getlonlatSimple(lon0,lat0,ROT):
    lonlat = np.array([lon0,lat0])
    xyz0=singlexyz(lonlat)
    xyz = np.dot(ROT,xyz0)
    
    lonlat2 = getlonlat(xyz[0],xyz[1],xyz[2],1)
    return lonlat2

def getNumDeriv(lon0,lat0,ROT):
    h = .0001
    lonlat0 = np.array([lon0,lat0])
    reflonlat1 = getlonlatSimple(lon0,lat0,ROT)
    lonlat1 = getlonlatSimple(lon0+h,lat0,ROT)
    dxdu = (lonlat1[0,0]-reflonlat1[0,0])/h
    dxdv = (lonlat1[0,1]-reflonlat1[0,1])/h
    lonlat2 = getlonlatSimple(lon0,lat0+h,ROT)
    dydu = (lonlat2[0,0]-reflonlat1[0,0])/h
    dydv = (lonlat2[0,1]-reflonlat1[0,1])/h
    #print dxdu,dxdv,dydu,dydv

    return (dxdu)

def Pframe2originalFrame(lonlatvecP,U):
    
    pqrVec ,pVec,qVec,rVec= getxyz(lonlatvecP) # mesh locations in P frame
    
    xyzVec = np.dot(U.T,pqrVec) # transforming mesh back to original frame
    lonlatVec = getlonlat(xyzVec[0,:],xyzVec[1,:],xyzVec[2:])
    return lonlatVec

def originalFrame2Pframe(lonlat,U):

    xyz,x,y,z = getxyz(lonlat)

    pqr = np.dot(U,xyz) # rotating point to new frame...(P frame)
    p = pqr[0,:] 
    q = pqr[1,:]
    r = pqr[2,:]
    lonlatPframe = getlonlat(p,q,r)
    '''
    plt.figure()
    plt.plot(lonlatPframe[:,0],lonlatPframe[:,1],'x')
    plt.show()
    '''
    lonlatPframe = lonlatChecks.fixlon4pdf(lonlatPframe,len(x)) # P frame should be technically in the principal axis
    
    return lonlatPframe



def getLonLatMesh(LonMesh,LatMesh,delta):
    minLon = np.min(LonMesh)
    maxLon = np.max(LonMesh)
    minLat = np.min(LatMesh)
    maxLat = np.max(LatMesh)

    lonvec = np.arange(minLon,maxLon,delta)
    latvec = np.arange(minLat,maxLat,delta)
    XX,YY = np.meshgrid(lonvec,latvec)
    return (XX,YY)
    



